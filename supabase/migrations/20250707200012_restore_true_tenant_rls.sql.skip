-- Restore TRUE RLS policies with proper tenant isolation
-- This replaces the overly permissive policies and SECURITY DEFINER functions

-- 1. First, drop all existing policies on user_profiles
DO $$
DECLARE
    pol RECORD;
BEGIN
    FOR pol IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' 
        AND tablename = 'user_profiles'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON public.user_profiles', pol.policyname);
    END LOOP;
END $$;

-- 2. Drop SECURITY DEFINER functions that bypass RLS
DROP FUNCTION IF EXISTS get_current_user_tenant() CASCADE;
DROP FUNCTION IF EXISTS get_auth_user_tenant_id() CASCADE;
DROP FUNCTION IF EXISTS is_user_admin() CASCADE;
DROP FUNCTION IF EXISTS temp_allow_all_access() CASCADE;

-- 3. Create proper RLS policies for user_profiles

-- Users can only see profiles in their own tenant
CREATE POLICY "tenant_isolation_select" ON user_profiles
    FOR SELECT
    USING (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    );

-- Users can only update their own profile
CREATE POLICY "own_profile_update" ON user_profiles
    FOR UPDATE
    USING (id = auth.uid())
    WITH CHECK (
        id = auth.uid() 
        AND tenant_id = (SELECT tenant_id FROM user_profiles WHERE id = auth.uid())
    );

-- Users can only insert their own profile on signup
CREATE POLICY "own_profile_insert" ON user_profiles
    FOR INSERT
    WITH CHECK (id = auth.uid());

-- Admins can manage profiles in their tenant
CREATE POLICY "admin_manage_profiles" ON user_profiles
    FOR ALL
    USING (
        EXISTS (
            SELECT 1 
            FROM user_profiles admin_profile
            WHERE admin_profile.id = auth.uid()
            AND admin_profile.tenant_id = user_profiles.tenant_id
            AND admin_profile.role IN ('admin', 'manager', 'supervisor')
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 
            FROM user_profiles admin_profile
            WHERE admin_profile.id = auth.uid()
            AND admin_profile.tenant_id = user_profiles.tenant_id
            AND admin_profile.role IN ('admin', 'manager', 'supervisor')
        )
    );

-- 4. Update RLS policies for other tables to use proper tenant isolation

-- Fix contacts table policies
DROP POLICY IF EXISTS "tenant_isolation" ON contacts;
DROP POLICY IF EXISTS "service_role_bypass_contacts" ON contacts;

CREATE POLICY "tenant_isolation_policy" ON contacts
    FOR ALL
    USING (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    )
    WITH CHECK (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    );

-- Fix accounts table policies
DROP POLICY IF EXISTS "tenant_isolation" ON accounts;
DROP POLICY IF EXISTS "service_role_bypass_accounts" ON accounts;

CREATE POLICY "tenant_isolation_policy" ON accounts
    FOR ALL
    USING (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    )
    WITH CHECK (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    );

-- Fix jobs table policies
DROP POLICY IF EXISTS "tenant_isolation" ON jobs;
DROP POLICY IF EXISTS "service_role_bypass_jobs" ON jobs;

CREATE POLICY "tenant_isolation_policy" ON jobs
    FOR ALL
    USING (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    )
    WITH CHECK (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    );

-- Fix leads table policies
DROP POLICY IF EXISTS "tenant_isolation" ON leads;
DROP POLICY IF EXISTS "service_role_bypass_leads" ON leads;

CREATE POLICY "tenant_isolation_policy" ON leads
    FOR ALL
    USING (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    )
    WITH CHECK (
        tenant_id IN (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
        )
    );

-- 5. Create a STABLE (not SECURITY DEFINER) function for tenant checks
-- This respects RLS instead of bypassing it
CREATE OR REPLACE FUNCTION auth_user_tenant_id()
RETURNS UUID
LANGUAGE sql
STABLE
AS $$
    SELECT tenant_id 
    FROM user_profiles 
    WHERE id = auth.uid()
    LIMIT 1;
$$;

-- 6. Create a function to check admin status without bypassing RLS
CREATE OR REPLACE FUNCTION auth_user_is_admin()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
AS $$
    SELECT EXISTS (
        SELECT 1 
        FROM user_profiles 
        WHERE id = auth.uid() 
        AND role IN ('admin', 'manager', 'supervisor')
    );
$$;

-- 7. Fix the team member creation to respect RLS
CREATE OR REPLACE FUNCTION create_team_member(
    p_email TEXT,
    p_first_name TEXT,
    p_last_name TEXT,
    p_role TEXT,
    p_phone TEXT DEFAULT NULL,
    p_department TEXT DEFAULT NULL,
    p_employee_id TEXT DEFAULT NULL,
    p_hourly_rate DECIMAL DEFAULT NULL,
    p_salary DECIMAL DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
DECLARE
    v_tenant_id UUID;
    v_profile_id UUID;
    v_caller_role TEXT;
BEGIN
    -- Get caller's tenant and role (respects RLS)
    SELECT tenant_id, role INTO v_tenant_id, v_caller_role
    FROM user_profiles
    WHERE id = auth.uid();
    
    -- Check permissions
    IF v_caller_role NOT IN ('admin', 'manager', 'supervisor') THEN
        RAISE EXCEPTION 'Insufficient permissions to create team members';
    END IF;
    
    -- Check if email already exists in this tenant
    IF EXISTS (
        SELECT 1 FROM user_profiles 
        WHERE email = p_email 
        AND tenant_id = v_tenant_id
    ) THEN
        RAISE EXCEPTION 'Email already exists in this tenant';
    END IF;
    
    -- Generate profile ID
    v_profile_id := gen_random_uuid();
    
    -- Create the profile (RLS will ensure it's in the right tenant)
    INSERT INTO user_profiles (
        id,
        tenant_id,
        email,
        first_name,
        last_name,
        role,
        phone,
        department,
        employee_id,
        hourly_rate,
        salary
    ) VALUES (
        v_profile_id,
        v_tenant_id,
        p_email,
        p_first_name,
        p_last_name,
        p_role,
        p_phone,
        p_department,
        p_employee_id,
        p_hourly_rate,
        p_salary
    );
    
    RETURN v_profile_id;
END;
$$;

-- 8. Update the view to respect RLS
CREATE OR REPLACE VIEW v_team_members AS
SELECT 
    up.id,
    up.tenant_id,
    up.email,
    up.first_name,
    up.last_name,
    up.first_name || ' ' || up.last_name as full_name,
    up.role,
    up.department,
    up.phone,
    up.avatar_url,
    up.is_active,
    up.created_at,
    up.updated_at,
    up.employee_id,
    up.hourly_rate,
    up.salary,
    CASE 
        WHEN au.id IS NOT NULL THEN true 
        ELSE false 
    END as has_auth_account,
    CASE
        WHEN au.last_sign_in_at IS NOT NULL THEN 'active'
        WHEN au.id IS NOT NULL THEN 'invited'
        ELSE 'pending'
    END as status
FROM user_profiles up
LEFT JOIN auth.users au ON au.id = up.id;

-- Grant access to the view
GRANT SELECT ON v_team_members TO authenticated;

-- 9. Add comments explaining the approach
COMMENT ON POLICY "tenant_isolation_select" ON user_profiles IS 
'Ensures users can only see profiles within their tenant by checking tenant_id';

COMMENT ON POLICY "own_profile_update" ON user_profiles IS 
'Users can only update their own profile, maintaining tenant association';

COMMENT ON POLICY "admin_manage_profiles" ON user_profiles IS 
'Admins can manage all profiles within their tenant only';

COMMENT ON FUNCTION auth_user_tenant_id() IS 
'Returns current user tenant_id, respects RLS (not SECURITY DEFINER)';

COMMENT ON FUNCTION auth_user_is_admin() IS 
'Checks if current user is admin, respects RLS (not SECURITY DEFINER)';

-- 10. Ensure RLS is enabled on all tenant-scoped tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;
ALTER TABLE estimates ENABLE ROW LEVEL SECURITY;
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;

-- 11. Log this change
INSERT INTO system_logs (action, details, user_id, created_at)
VALUES (
    'rls_policies_restored',
    json_build_object(
        'description', 'Restored proper RLS policies without SECURITY DEFINER bypass',
        'affected_tables', ARRAY['user_profiles', 'contacts', 'accounts', 'jobs', 'leads']
    ),
    auth.uid(),
    NOW()
);