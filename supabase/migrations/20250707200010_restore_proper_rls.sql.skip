-- Restore proper RLS policies after fixing the infinite recursion issue
-- This migration adds back tenant-based isolation with proper safeguards

-- 1. First, let's create a safe function to get current user's tenant
CREATE OR REPLACE FUNCTION get_current_user_tenant()
RETURNS UUID
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_tenant_id UUID;
BEGIN
    -- Use a simple direct query with no recursion possible
    SELECT tenant_id INTO v_tenant_id
    FROM user_profiles
    WHERE id = auth.uid()
    LIMIT 1;
    
    RETURN v_tenant_id;
END;
$$;

-- 2. Create a function to check if user is admin
CREATE OR REPLACE FUNCTION is_user_admin()
RETURNS BOOLEAN
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_role TEXT;
BEGIN
    SELECT role INTO v_role
    FROM user_profiles
    WHERE id = auth.uid()
    LIMIT 1;
    
    RETURN v_role IN ('admin', 'manager', 'supervisor');
END;
$$;

-- 3. Drop the temporary policy
DROP POLICY IF EXISTS "temp_allow_authenticated" ON user_profiles;

-- 4. Create proper tenant-based policies

-- Users can read their own profile
CREATE POLICY "users_read_own_profile" ON user_profiles
    FOR SELECT
    USING (id = auth.uid());

-- Users can update their own profile
CREATE POLICY "users_update_own_profile" ON user_profiles
    FOR UPDATE
    USING (id = auth.uid())
    WITH CHECK (id = auth.uid() AND tenant_id = get_current_user_tenant());

-- Users can read profiles in their tenant
CREATE POLICY "users_read_tenant_profiles" ON user_profiles
    FOR SELECT
    USING (
        tenant_id = get_current_user_tenant()
        OR id = auth.uid()  -- Always allow reading own profile
    );

-- Admins can manage profiles in their tenant
CREATE POLICY "admins_manage_tenant_profiles" ON user_profiles
    FOR ALL
    USING (
        is_user_admin() 
        AND tenant_id = get_current_user_tenant()
    )
    WITH CHECK (
        is_user_admin() 
        AND tenant_id = get_current_user_tenant()
    );

-- Service role bypass (for system operations)
CREATE POLICY "service_role_bypass" ON user_profiles
    FOR ALL
    USING (auth.role() = 'service_role');

-- 5. Grant necessary permissions
GRANT EXECUTE ON FUNCTION get_current_user_tenant() TO authenticated;
GRANT EXECUTE ON FUNCTION is_user_admin() TO authenticated;

-- 6. Add RLS to other tables that need it
-- Enable RLS on contacts
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;

-- Contacts policies
CREATE POLICY "tenant_isolation" ON contacts
    FOR ALL
    USING (tenant_id = get_current_user_tenant())
    WITH CHECK (tenant_id = get_current_user_tenant());

CREATE POLICY "service_role_bypass_contacts" ON contacts
    FOR ALL
    USING (auth.role() = 'service_role');

-- Enable RLS on accounts
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

-- Accounts policies  
CREATE POLICY "tenant_isolation" ON accounts
    FOR ALL
    USING (tenant_id = get_current_user_tenant())
    WITH CHECK (tenant_id = get_current_user_tenant());

CREATE POLICY "service_role_bypass_accounts" ON accounts
    FOR ALL
    USING (auth.role() = 'service_role');

-- Enable RLS on jobs
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;

-- Jobs policies
CREATE POLICY "tenant_isolation" ON jobs
    FOR ALL
    USING (tenant_id = get_current_user_tenant())
    WITH CHECK (tenant_id = get_current_user_tenant());

CREATE POLICY "service_role_bypass_jobs" ON jobs
    FOR ALL
    USING (auth.role() = 'service_role');

-- Enable RLS on leads
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;

-- Leads policies
CREATE POLICY "tenant_isolation" ON leads
    FOR ALL
    USING (tenant_id = get_current_user_tenant())
    WITH CHECK (tenant_id = get_current_user_tenant());

CREATE POLICY "service_role_bypass_leads" ON leads
    FOR ALL
    USING (auth.role() = 'service_role');

-- 7. Create a function to properly create auth users for existing profiles
-- This will help fix the issue where users exist in profiles but not auth
CREATE OR REPLACE FUNCTION create_auth_user_for_profile(
    p_profile_id UUID,
    p_email TEXT,
    p_password TEXT
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_user_id UUID;
    v_result JSON;
BEGIN
    -- Check if profile exists
    IF NOT EXISTS (SELECT 1 FROM user_profiles WHERE id = p_profile_id AND email = p_email) THEN
        RETURN json_build_object('success', false, 'error', 'Profile not found');
    END IF;
    
    -- Check if auth user already exists
    IF EXISTS (SELECT 1 FROM auth.users WHERE email = p_email) THEN
        -- Update the profile to link to existing auth user
        UPDATE user_profiles 
        SET id = (SELECT id FROM auth.users WHERE email = p_email LIMIT 1)
        WHERE id = p_profile_id;
        
        RETURN json_build_object('success', true, 'message', 'Linked to existing auth user');
    END IF;
    
    -- For new auth users, this would need to be done through Supabase Auth API
    -- Return instructions for manual creation
    RETURN json_build_object(
        'success', false, 
        'message', 'Auth user needs to be created via invite flow',
        'instructions', 'Use the invite_team_member function or send password reset email'
    );
END;
$$;

GRANT EXECUTE ON FUNCTION create_auth_user_for_profile(UUID, TEXT, TEXT) TO authenticated;

-- 8. Fix the invite_team_member function to properly create auth users
CREATE OR REPLACE FUNCTION invite_team_member(
    p_profile_id UUID,
    p_invitation_message TEXT DEFAULT 'You have been invited to join our team!'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_email TEXT;
    v_tenant_id UUID;
    v_inviter_name TEXT;
    v_company_name TEXT;
BEGIN
    -- Get profile details
    SELECT email, tenant_id 
    INTO v_email, v_tenant_id
    FROM user_profiles 
    WHERE id = p_profile_id;
    
    IF v_email IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Profile not found');
    END IF;
    
    -- Get inviter details
    SELECT first_name || ' ' || last_name 
    INTO v_inviter_name
    FROM user_profiles 
    WHERE id = auth.uid();
    
    -- Get company name
    SELECT company_name 
    INTO v_company_name
    FROM tenants 
    WHERE id = v_tenant_id;
    
    -- Create invitation record
    INSERT INTO team_invitations (
        profile_id,
        email,
        tenant_id,
        invited_by,
        invitation_message,
        expires_at
    ) VALUES (
        p_profile_id,
        v_email,
        v_tenant_id,
        auth.uid(),
        p_invitation_message,
        NOW() + INTERVAL '7 days'
    );
    
    -- Queue email to be sent
    INSERT INTO email_queue (
        to_email,
        subject,
        body,
        template_id,
        template_data,
        scheduled_for
    ) VALUES (
        v_email,
        'You''ve been invited to join ' || COALESCE(v_company_name, 'our team'),
        p_invitation_message,
        'team_invitation',
        json_build_object(
            'inviter_name', v_inviter_name,
            'company_name', v_company_name,
            'invitation_message', p_invitation_message,
            'invitation_link', 'https://your-app-url.com/auth/accept-invite?token=' || encode(gen_random_bytes(32), 'hex')
        ),
        NOW()
    );
    
    RETURN json_build_object(
        'success', true, 
        'message', 'Invitation sent successfully',
        'profile_id', p_profile_id,
        'email', v_email
    );
END;
$$;

-- 9. Create the team_invitations table if it doesn't exist
CREATE TABLE IF NOT EXISTS team_invitations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    profile_id UUID REFERENCES user_profiles(id),
    email TEXT NOT NULL,
    tenant_id UUID REFERENCES tenants(id),
    invited_by UUID REFERENCES user_profiles(id),
    invitation_message TEXT,
    token TEXT DEFAULT encode(gen_random_bytes(32), 'hex'),
    accepted_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS on team_invitations
ALTER TABLE team_invitations ENABLE ROW LEVEL SECURITY;

-- Policies for team_invitations
CREATE POLICY "users_read_own_invitations" ON team_invitations
    FOR SELECT
    USING (email = auth.jwt()->>'email' OR invited_by = auth.uid());

CREATE POLICY "admins_manage_tenant_invitations" ON team_invitations
    FOR ALL
    USING (
        is_user_admin() 
        AND tenant_id = get_current_user_tenant()
    );

CREATE POLICY "service_role_bypass_invitations" ON team_invitations
    FOR ALL
    USING (auth.role() = 'service_role');

-- 10. Create email_queue table if it doesn't exist
CREATE TABLE IF NOT EXISTS email_queue (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    to_email TEXT NOT NULL,
    cc_email TEXT,
    bcc_email TEXT,
    subject TEXT NOT NULL,
    body TEXT,
    template_id TEXT,
    template_data JSONB,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'sending', 'sent', 'failed')),
    error_message TEXT,
    sent_at TIMESTAMPTZ,
    scheduled_for TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for processing
CREATE INDEX IF NOT EXISTS idx_email_queue_status_scheduled 
ON email_queue(status, scheduled_for) 
WHERE status = 'pending';

-- Grant permissions
GRANT SELECT, INSERT ON email_queue TO authenticated;
GRANT ALL ON email_queue TO service_role;

-- 11. Add helpful comments
COMMENT ON FUNCTION get_current_user_tenant() IS 'Safely returns the current user tenant_id without recursion';
COMMENT ON FUNCTION is_user_admin() IS 'Checks if current user has admin privileges';
COMMENT ON FUNCTION create_auth_user_for_profile(UUID, TEXT, TEXT) IS 'Helper to create auth user for existing profile';
COMMENT ON FUNCTION invite_team_member(UUID, TEXT) IS 'Sends invitation email to team member to complete registration';