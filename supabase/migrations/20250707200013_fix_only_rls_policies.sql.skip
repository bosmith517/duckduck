-- Fix ONLY the RLS policies while preserving legitimate SECURITY DEFINER functions
-- This migration targets only the problematic user_profiles and related table policies

-- 1. Drop only the problematic RLS-bypassing functions
DROP FUNCTION IF EXISTS temp_allow_all_access() CASCADE;
DROP FUNCTION IF EXISTS get_current_user_tenant() CASCADE; -- This one bypassed RLS
DROP FUNCTION IF EXISTS is_user_admin() CASCADE; -- This one bypassed RLS

-- Keep legitimate SECURITY DEFINER functions like:
-- - calculate_sip_usage (for call statistics)
-- - create_admin_notification (for system notifications)
-- - Other specific operational functions

-- 2. Fix user_profiles policies only
-- Drop all existing policies on user_profiles
DO $$
DECLARE
    pol RECORD;
BEGIN
    FOR pol IN 
        SELECT policyname 
        FROM pg_policies 
        WHERE schemaname = 'public' 
        AND tablename = 'user_profiles'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON public.user_profiles', pol.policyname);
    END LOOP;
END $$;

-- 3. Create proper RLS policies for user_profiles

-- Users can read their own profile
CREATE POLICY "users_read_own" ON user_profiles
    FOR SELECT
    USING (id = auth.uid());

-- Users can read profiles in their tenant
CREATE POLICY "users_read_same_tenant" ON user_profiles
    FOR SELECT  
    USING (
        tenant_id = (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
            LIMIT 1
        )
    );

-- Users can update only their own profile
CREATE POLICY "users_update_own" ON user_profiles
    FOR UPDATE
    USING (id = auth.uid())
    WITH CHECK (id = auth.uid());

-- Users can insert their own profile (during signup)
CREATE POLICY "users_insert_own" ON user_profiles
    FOR INSERT
    WITH CHECK (id = auth.uid());

-- Admins can manage profiles in their tenant
CREATE POLICY "admins_manage_tenant_profiles" ON user_profiles
    FOR ALL
    USING (
        -- User is admin/manager/supervisor
        EXISTS (
            SELECT 1 
            FROM user_profiles up
            WHERE up.id = auth.uid()
            AND up.role IN ('admin', 'manager', 'supervisor')
            LIMIT 1
        )
        AND
        -- Target profile is in same tenant
        tenant_id = (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
            LIMIT 1
        )
    )
    WITH CHECK (
        -- User is admin/manager/supervisor
        EXISTS (
            SELECT 1 
            FROM user_profiles up
            WHERE up.id = auth.uid()
            AND up.role IN ('admin', 'manager', 'supervisor')
            LIMIT 1
        )
        AND
        -- Target profile is in same tenant
        tenant_id = (
            SELECT tenant_id 
            FROM user_profiles 
            WHERE id = auth.uid()
            LIMIT 1
        )
    );

-- 4. Fix the create_team_member function to not use SECURITY DEFINER
DROP FUNCTION IF EXISTS create_team_member CASCADE;

CREATE OR REPLACE FUNCTION create_team_member(
    p_email TEXT,
    p_first_name TEXT,
    p_last_name TEXT,
    p_role TEXT,
    p_phone TEXT DEFAULT NULL,
    p_department TEXT DEFAULT NULL,
    p_employee_id TEXT DEFAULT NULL,
    p_hourly_rate DECIMAL DEFAULT NULL,
    p_salary DECIMAL DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
-- NO SECURITY DEFINER - respects RLS
AS $$
DECLARE
    v_tenant_id UUID;
    v_profile_id UUID;
    v_caller_role TEXT;
BEGIN
    -- Get caller's tenant and role (RLS will apply)
    SELECT tenant_id, role INTO v_tenant_id, v_caller_role
    FROM user_profiles
    WHERE id = auth.uid()
    LIMIT 1;
    
    -- Check permissions
    IF v_caller_role NOT IN ('admin', 'manager', 'supervisor') THEN
        RAISE EXCEPTION 'Insufficient permissions to create team members';
    END IF;
    
    -- Check if email already exists
    IF EXISTS (
        SELECT 1 FROM user_profiles 
        WHERE email = p_email
        LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Email already exists';
    END IF;
    
    -- Generate new profile ID
    v_profile_id := gen_random_uuid();
    
    -- Insert the profile (RLS will be enforced)
    INSERT INTO user_profiles (
        id,
        tenant_id,
        email,
        first_name,
        last_name,
        role,
        phone,
        department,
        employee_id,
        hourly_rate,
        salary,
        created_at,
        updated_at
    ) VALUES (
        v_profile_id,
        v_tenant_id,
        p_email,
        p_first_name,
        p_last_name,
        p_role,
        p_phone,
        p_department,
        p_employee_id,
        p_hourly_rate,
        p_salary,
        NOW(),
        NOW()
    );
    
    RETURN v_profile_id;
END;
$$;

-- 5. Create helper functions that respect RLS (not SECURITY DEFINER)
CREATE OR REPLACE FUNCTION current_user_tenant()
RETURNS UUID
LANGUAGE sql
STABLE
AS $$
    SELECT tenant_id 
    FROM user_profiles 
    WHERE id = auth.uid()
    LIMIT 1;
$$;

CREATE OR REPLACE FUNCTION current_user_role()
RETURNS TEXT
LANGUAGE sql
STABLE
AS $$
    SELECT role 
    FROM user_profiles 
    WHERE id = auth.uid()
    LIMIT 1;
$$;

-- 6. Fix other table policies to remove complexity
-- Only fix the ones that referenced the problematic functions

-- Fix contacts policies
DROP POLICY IF EXISTS "tenant_isolation" ON contacts;
DROP POLICY IF EXISTS "service_role_bypass_contacts" ON contacts;
DROP POLICY IF EXISTS "tenant_isolation_policy" ON contacts;

CREATE POLICY "tenant_isolation" ON contacts
    FOR ALL
    USING (tenant_id = current_user_tenant())
    WITH CHECK (tenant_id = current_user_tenant());

-- Fix accounts policies  
DROP POLICY IF EXISTS "tenant_isolation" ON accounts;
DROP POLICY IF EXISTS "service_role_bypass_accounts" ON accounts;
DROP POLICY IF EXISTS "tenant_isolation_policy" ON accounts;

CREATE POLICY "tenant_isolation" ON accounts
    FOR ALL
    USING (tenant_id = current_user_tenant())
    WITH CHECK (tenant_id = current_user_tenant());

-- Fix jobs policies
DROP POLICY IF EXISTS "tenant_isolation" ON jobs;
DROP POLICY IF EXISTS "service_role_bypass_jobs" ON jobs;
DROP POLICY IF EXISTS "tenant_isolation_policy" ON jobs;

CREATE POLICY "tenant_isolation" ON jobs
    FOR ALL
    USING (tenant_id = current_user_tenant())
    WITH CHECK (tenant_id = current_user_tenant());

-- Fix leads policies
DROP POLICY IF EXISTS "tenant_isolation" ON leads;
DROP POLICY IF EXISTS "service_role_bypass_leads" ON leads;
DROP POLICY IF EXISTS "tenant_isolation_policy" ON leads;

CREATE POLICY "tenant_isolation" ON leads
    FOR ALL
    USING (tenant_id = current_user_tenant())
    WITH CHECK (tenant_id = current_user_tenant());

-- 7. Grant necessary permissions
GRANT EXECUTE ON FUNCTION current_user_tenant() TO authenticated;
GRANT EXECUTE ON FUNCTION current_user_role() TO authenticated;
GRANT EXECUTE ON FUNCTION create_team_member(TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, DECIMAL, DECIMAL) TO authenticated;

-- 8. Ensure RLS is enabled
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;

-- 9. Add comments
COMMENT ON FUNCTION current_user_tenant() IS 'Returns current user tenant_id, respects RLS';
COMMENT ON FUNCTION current_user_role() IS 'Returns current user role, respects RLS';
COMMENT ON POLICY "users_read_same_tenant" ON user_profiles IS 'Allow users to see profiles in their tenant';
COMMENT ON POLICY "admins_manage_tenant_profiles" ON user_profiles IS 'Allow admins to manage profiles in their tenant only';